WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:05.759
本视频将讲解可变和不可变数据类型及函数

00:00:05.759 --> 00:00:09.689
回想一下 我们曾经探讨过可变与不可变数据类型

00:00:09.689 --> 00:00:12.330
当时上的课程是

00:00:12.330 --> 00:00:15.019
数据类型、运算符、列表与成员运算符

00:00:15.019 --> 00:00:17.939
重温一下 可变数据类型

00:00:17.940 --> 00:00:21.405
在创建后可以更改 不可变数据类型则不能

00:00:21.405 --> 00:00:26.220
不可变数据类型有布尔值、整数、浮点数、元组和字符串

00:00:26.219 --> 00:00:31.785
而可变数据类型有列表、字典和集合

00:00:31.785 --> 00:00:35.820
正如课程 “函数-变量范围” 所讲

00:00:35.820 --> 00:00:41.381
不可变数据类型是以原对象副本的形式输入函数的

00:00:41.381 --> 00:00:46.934
也就是说 副本发生的变化不会影响原对象

00:00:46.935 --> 00:00:49.099
而可变数据类型

00:00:49.098 --> 00:00:52.589
则是以原对象指针的形式输入函数的

00:00:52.590 --> 00:00:56.235
也就意味着无论指针在函数里有何变化

00:00:56.234 --> 00:00:59.924
原对象都会随之改变

00:00:59.924 --> 00:01:01.409
你可以复习

00:01:01.409 --> 00:01:05.834
“函数-变量范围” 一课 重温不可变数据类型的范围

00:01:05.834 --> 00:01:08.354
本视频将讲授可变数据类型的范围

00:01:08.355 --> 00:01:12.075
并借助三个例子进行阐述

00:01:12.075 --> 00:01:14.850
虽然我们以列表为例

00:01:14.849 --> 00:01:17.771
但其原理适用于其它任意可变数据类型

00:01:17.772 --> 00:01:20.292
比如字典或集合

00:01:20.292 --> 00:01:21.629
第一个例子

00:01:21.629 --> 00:01:25.572
列表范围会延伸到函数内部

00:01:25.572 --> 00:01:27.750
此时列表是在函数外部创建的

00:01:27.750 --> 00:01:31.668
并以参数的形式输入到函数内部

00:01:31.668 --> 00:01:33.150
第二个例子

00:01:33.150 --> 00:01:36.780
列表范围局限于函数之内

00:01:36.780 --> 00:01:41.081
此时列表由函数创建 但不会经函数返回而出

00:01:41.081 --> 00:01:42.494
第三个例子

00:01:42.495 --> 00:01:45.765
列表范围可扩展到函数外部

00:01:45.765 --> 00:01:49.430
此时列表由函数创建并经函数返回而出

00:01:49.430 --> 00:01:52.730
每个例子都会在左边演示代码

00:01:52.730 --> 00:01:56.480
在右边演示计算机内存运行的情况

00:01:56.480 --> 00:01:59.960
在本例中 列表在函数外部得到创建

00:01:59.959 --> 00:02:05.549
随后会作为参数输入到函数之中

00:02:05.549 --> 00:02:10.329
观察第一行 列表在内存中得到创建

00:02:10.330 --> 00:02:15.445
此时 指针 dogs 指向列表在内存中的存储位置

00:02:15.444 --> 00:02:22.134
第二行 我们将指针 dogs 作为参数输入到函数 edit_pets 中

00:02:22.134 --> 00:02:25.449
从而创建出第二个指针 pets

00:02:25.449 --> 00:02:29.027
该指针也指向列表在内存中的存储位置

00:02:29.027 --> 00:02:34.164
指针 pets 只存在于函数 edit_pets 之中

00:02:34.164 --> 00:02:37.120
函数 edit_pets 的第一行

00:02:37.120 --> 00:02:41.360
指针 pets 将列表值 Cody 从列表中弹出

00:02:41.360 --> 00:02:44.260
因此 字符串 Cody 被移出了列表

00:02:44.259 --> 00:02:50.454
列表剩下的内容则会自动调整以填补 Cody 的空缺

00:02:50.455 --> 00:02:53.380
函数 edit_pets 的第二行

00:02:53.379 --> 00:02:58.521
指针 pets 在列表末端追加了 Bella

00:02:58.521 --> 00:03:00.429
函数 edit_pets 的第三行

00:03:00.430 --> 00:03:04.675
指针 pets 在列表末端追加了 Buddy

00:03:04.675 --> 00:03:11.487
注意 “+=” 运算符的作用就是在列表末端追加值

00:03:11.487 --> 00:03:13.134
代码第三行

00:03:13.134 --> 00:03:15.219
会输出列表 dogs

00:03:15.219 --> 00:03:17.490
注意 在函数外部

00:03:17.490 --> 00:03:21.140
内存里已经没有指针 pets 了

00:03:21.139 --> 00:03:28.039
但 pets 在函数中造成的变化会延续到函数外部

00:03:28.039 --> 00:03:29.870
使用指针 dogs

00:03:29.870 --> 00:03:32.270
输出的列表

00:03:32.270 --> 00:03:35.555
会保留指针 pets 在函数内的修改痕迹

00:03:35.555 --> 00:03:40.159
在本例中 列表会在函数内部得到创建

00:03:40.159 --> 00:03:45.150
但不由函数返回 而且只存在于函数内部

00:03:45.150 --> 00:03:52.710
第一行调用了函数 edit_pets2 内存还什么都没有

00:03:52.710 --> 00:03:54.689
函数 edit_pets2 的第一行

00:03:54.689 --> 00:03:57.824
列表在内存中得到创建

00:03:57.824 --> 00:04:02.114
其中 指针 pets 指向列表在内存中的存储位置

00:04:02.115 --> 00:04:05.189
函数 edit_pets2 的第二行

00:04:05.189 --> 00:04:09.284
指针 pets 将列表值 Cody 弹出列表

00:04:09.284 --> 00:04:12.569
因此字符串 Cody 被移出了列表

00:04:12.569 --> 00:04:17.969
列表剩下的内容则会自动调整以填补 Cody 的空缺

00:04:17.970 --> 00:04:20.670
函数 edit_pets2 的第三行

00:04:20.670 --> 00:04:25.050
指针 pets 在列表末端追加了 Bella

00:04:25.050 --> 00:04:28.689
函数 edit_pets2 的第四行

00:04:28.689 --> 00:04:33.879
指针 pets 在列表末端追加了 Buddy

00:04:33.879 --> 00:04:36.925
代码第二行

00:04:36.925 --> 00:04:39.160
输出字符串 Done 表示已完成操作

00:04:39.160 --> 00:04:41.905
注意 在函数外部

00:04:41.904 --> 00:04:46.524
指针 pets 和列表不再存在于内存中

00:04:46.524 --> 00:04:51.189
本例中 列表会在函数内部得到创建

00:04:51.189 --> 00:04:57.180
并经函数返回而出 列表将存在于函数外部

00:04:57.180 --> 00:05:04.790
第一行调用了函数 edit_pets3 内存还什么都没有

00:05:04.790 --> 00:05:06.655
函数 edit_pets3 的第一行

00:05:06.654 --> 00:05:08.559
列表在内存中得到创建

00:05:08.560 --> 00:05:13.134
其中 指针 pets 指向列表在内存中的存储位置

00:05:13.134 --> 00:05:15.879
函数 edit_pets3 的第二行

00:05:15.879 --> 00:05:18.310
指针 pets 将列表值 Cody 弹出了列表

00:05:18.310 --> 00:05:21.459
因此字符串 Cody 被移出了列表

00:05:21.459 --> 00:05:27.625
列表剩下的内容则会自动调整以填补 Cody 的空缺

00:05:27.625 --> 00:05:29.980
函数 edit_pets3 的第三行

00:05:29.980 --> 00:05:34.725
指针 pets 在列表末端追加了 Bella

00:05:34.725 --> 00:05:36.430
函数 edit_pets3 的第四行

00:05:36.430 --> 00:05:40.420
指针 pets 在列表末端追加了 Buddy

00:05:40.420 --> 00:05:46.900
函数 edit_pets3 的第五行 函数返回出了指针 pets

00:05:46.899 --> 00:05:49.689
由此 程序创建了指针 dogs

00:05:49.689 --> 00:05:53.019
该指针也指向列表在内存中的存储位置

00:05:53.019 --> 00:05:55.750
注意 在函数外部

00:05:55.750 --> 00:05:58.839
内存不再有指针 pets

00:05:58.839 --> 00:06:02.784
但仍有指针 dogs 和列表

00:06:02.785 --> 00:06:06.443
因为函数已经把列表返回出来了

00:06:06.442 --> 00:06:09.474
代码第二行 使用指针 dogs

00:06:09.475 --> 00:06:12.720
输出函数 edit_pets3 创建的列表

